import streamlit as st
import pandas as pd
import requests
import json
import os
import uuid
from datetime import datetime
from lotofacil import (
    carregar_dados,
    calcular_frequencia,
    calcular_atrasos,
    calcular_pares_impares,
    calcular_sequencias,
    analisar_combinacoes_repetidas,
    gerar_jogos_balanceados,
    calcular_valor_aposta,
    gerar_pdf_jogos,
    obter_concurso_atual_api,
    atualizar_csv_github,
    salvar_bolao_csv,
    calcular_soma_total,
    avaliar_jogos_historico  # üîπ nova fun√ß√£o adicionada
)

# ---------------------------
# Configura√ß√£o geral
# ---------------------------
st.set_page_config(page_title="Lotof√°cil Inteligente", page_icon="üé≤", layout="wide")
st.title("üé≤ Painel Lotof√°cil Inteligente")

# ---------------------------
# Carregar base
# ---------------------------
if st.button("üîÑ Atualizar base com √∫ltimo concurso"):
    with st.spinner("Verificando novo concurso..."):
        resultado = atualizar_csv_github()
    st.success(resultado)
    st.rerun()  # ‚úÖ recarrega automaticamente ap√≥s atualiza√ß√£o

file_path = "Lotofacil_Concursos.csv"
df = carregar_dados(file_path)

if df is None:
    st.error("‚ùå Erro ao carregar os concursos!")
    st.stop()
else:
    st.success(f"‚úÖ Concursos carregados: {len(df)}")

dados_api = obter_concurso_atual_api()
if dados_api:
    numero_api = dados_api["numero"]
    st.info(f"üìÖ √öltimo concurso oficial: **{numero_api}** ({dados_api['dataApuracao']})")

# ---------------------------
# Abas principais
# ---------------------------
aba = st.sidebar.radio(
    "üìç Menu Principal",
    ["üìä Pain√©is Estat√≠sticos", "üéØ Gera√ß√£o de Jogos", "üìã Conferir Bol√£o", "üßÆ Conferir Jogos Manuais"]
)

# ---------------------------
# üìä Aba 1 ‚Äì Pain√©is Estat√≠sticos
# ---------------------------
if aba == "üìä Pain√©is Estat√≠sticos":
    st.header("üìä Pain√©is Estat√≠sticos da Lotof√°cil")

    # Slider para quantidade de concursos analisados
    ultimos = st.slider("Selecione quantos concursos deseja analisar:", 50, len(df), len(df))

    # üîπ Agrupando tudo em abas (tabs)
    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs([
        "üìà Frequ√™ncia",
        "‚è≥ Atrasos",
        "‚öñÔ∏è Pares/√çmpares",
        "üîó Combina√ß√µes",
        "‚ûï Soma",
        "üìä Sequ√™ncias"
    ])

    # --- üìà Frequ√™ncia ---
    with tab1:
        st.subheader("üìà Frequ√™ncia das Dezenas")
        freq = calcular_frequencia(df, ultimos)
        st.bar_chart(freq.set_index("Dezena")["Frequ√™ncia"])  # gr√°fico r√°pido
        st.dataframe(freq, use_container_width=True)

    # --- ‚è≥ Atrasos ---
    with tab2:
        st.subheader("‚è≥ Atrasos das Dezenas")
        atrasos = calcular_atrasos(df)
        st.bar_chart(atrasos.set_index("Dezena")["Atraso Atual"])
        st.dataframe(atrasos, use_container_width=True)

    # --- ‚öñÔ∏è Pares e √çmpares ---
    with tab3:
        st.subheader("‚öñÔ∏è Distribui√ß√£o de Pares e √çmpares")
        pares_impares = calcular_pares_impares(df)
        st.dataframe(pares_impares, use_container_width=True)
        st.markdown("üí° **Dica:** o equil√≠brio ideal costuma ficar entre 6x9 e 9x6 (pares/√≠mpares).")

    # --- üîó Combina√ß√µes Repetidas ---
    with tab4:
        st.subheader("üîó Combina√ß√µes Mais Frequentes")
        combinacoes = analisar_combinacoes_repetidas(df)

        for tamanho, tabela in combinacoes.items():
            st.markdown(f"**Top 5 combina√ß√µes de {tamanho} dezenas:**")
            st.dataframe(tabela, use_container_width=True)

        st.info("üí° Essas combina√ß√µes indicam duplas, trios e grupos que mais aparecem juntas nos sorteios.")

    # --- ‚ûï Soma das Dezenas ---
    with tab5:
        st.subheader("‚ûï An√°lise da Soma Total das Dezenas")
        df_soma, resumo = calcular_soma_total(df)

        # --- Painel de m√©tricas ---
        col_min, col_med, col_max = st.columns(3)
        col_min.metric("üîª Soma M√≠nima", f"{resumo['Soma M√≠nima']}")
        col_med.metric("‚öñÔ∏è Soma M√©dia", f"{resumo['Soma M√©dia']:.2f}")
        col_max.metric("üî∫ Soma M√°xima", f"{resumo['Soma M√°xima']}")

        # --- √öltimos concursos ---
        st.markdown("**√öltimos concursos (soma total):**")
        st.dataframe(df_soma.tail(), use_container_width=True)
        st.line_chart(df_soma.set_index("Concurso")["Soma"], height=250)

        st.info("üí° A soma total costuma variar entre **170 e 210**. "
                "Evite jogos muito fora dessa faixa para manter o padr√£o estat√≠stico.")

    # --- üìä Sequ√™ncias ---
    with tab6:
        st.subheader("üìä Tamanho de Sequ√™ncias Consecutivas")
        sequencias = calcular_sequencias(df)
        st.bar_chart(sequencias.set_index("Tamanho Sequ√™ncia")["Ocorr√™ncias"])
        st.dataframe(sequencias, use_container_width=True)
        st.markdown("üí° Em geral, sequ√™ncias de 2 ou 3 n√∫meros consecutivos s√£o mais comuns.")




# --------------------------
# üéØ Aba 2 ‚Äì Gera√ß√£o de Jogos Inteligente
# --------------------------
if aba == "üéØ Gera√ß√£o de Jogos":
    st.header("üÉè Gera√ß√£o de Jogos Inteligente")

    # padr√£o: usar TODOS os concursos para estat√≠sticas
    ranking = calcular_frequencia(df, ultimos=None)
    atrasos = calcular_atrasos(df)
    # --------------------------
    # üîç Destaques de dezenas
    # --------------------------
    
    # Top 3 atrasadas (com atraso atual)
    top_atrasadas = atrasos.sort_values("Atraso Atual", ascending=False).head(3)[["Dezena", "Atraso Atual"]]
    top_frequentes = ranking.sort_values("Frequ√™ncia", ascending=False).head(10)[["Dezena", "Frequ√™ncia"]]
    
    # Cria DataFrame para exibi√ß√£o lado a lado
    col1, col2 = st.columns(2)

    with col1:
        st.markdown("### üî¥ Top 3 Dezenas Mais Atrasadas")
        st.table(pd.DataFrame({
            "Dezena": [f"{int(row['Dezena']):02d}" for _, row in top_atrasadas.iterrows()],
            "Concursos em Atraso": [int(row["Atraso Atual"]) for _, row in top_atrasadas.iterrows()]
        }))
    
    with col2:
        st.markdown("### üîµ Top 10 Dezenas Mais Frequentes")
        st.table(pd.DataFrame({
            "Dezena": [f"{int(row['Dezena']):02d}" for _, row in top_frequentes.iterrows()],
            "Qtd Sorteios": [int(row["Frequ√™ncia"]) for _, row in top_frequentes.iterrows()]
        }))


    st.markdown("### üß© Escolha quantos jogos de cada tipo deseja gerar")
    qtd_15 = st.number_input("üéØ Jogos de 15 dezenas", 0, 50, 0)
    qtd_16 = st.number_input("üéØ Jogos de 16 dezenas", 0, 50, 0)
    qtd_17 = st.number_input("üéØ Jogos de 17 dezenas", 0, 50, 0)
    qtd_18 = st.number_input("üéØ Jogos de 18 dezenas", 0, 50, 0)
    qtd_19 = st.number_input("üéØ Jogos de 19 dezenas", 0, 50, 0)
    qtd_20 = st.number_input("üéØ Jogos de 20 dezenas", 0, 50, 0)

    total_jogos = sum([qtd_15, qtd_16, qtd_17, qtd_18, qtd_19, qtd_20])
    if total_jogos == 0:
        st.info("Informe pelo menos 1 jogo para gerar (escolha quantidades acima).")
    else:
        if st.button("üé≤ Gerar Jogos Balanceados"):
            tamanhos_qtd = {
                15: qtd_15,
                16: qtd_16,
                17: qtd_17,
                18: qtd_18,
                19: qtd_19,
                20: qtd_20
            }
            jogos_gerados = []
            for tam, qtd in tamanhos_qtd.items():
                if qtd > 0:
                    lista_temp = gerar_jogos_balanceados(df, qtd_jogos=qtd, tamanho=tam)
                    jogos_gerados.extend(lista_temp)

            # guarda no session_state
            st.session_state["jogos_gerados"] = jogos_gerados

            # salva em CSV no diret√≥rio atual (append)
            try:
                import os
                from datetime import datetime
                file_path = os.path.join(os.getcwd(), "jogos_gerados.csv")
                criar_cabecalho = not os.path.exists(file_path)
                linhas = []
                for i, (jogo, _) in enumerate(jogos_gerados, start=1):
                    linhas.append({
                        "ID": i,
                        "DataHora": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                        "Tamanho": len(jogo),
                        "Dezenas": ",".join(str(d) for d in sorted(jogo))
                    })
                df_save = pd.DataFrame(linhas)
                df_save.to_csv(file_path, mode="a", index=False, header=criar_cabecalho, encoding="utf-8")
                st.success(f"‚úÖ {len(jogos_gerados)} jogos gerados e salvos em {file_path}!")
            except Exception as e:
                st.error(f"‚ùå Erro ao salvar jogos: {e}")

            # Avalia√ß√£o hist√≥rica (11..15)
            st.markdown("---")
            st.subheader("üìä Avalia√ß√£o Hist√≥rica dos Jogos")
            try:
                avaliacao = avaliar_jogos_historico(df, jogos_gerados)
                st.dataframe(avaliacao, use_container_width=True)
            except Exception as e:
                st.error(f"Erro ao avaliar historicamente: {e}")

    # exibe jogos gerados (se houver)
    if "jogos_gerados" in st.session_state:
        jogos = st.session_state["jogos_gerados"]
        st.markdown("---")
        st.subheader("üéØ Jogos Gerados")
        # --------------------------
        # üéØ Legenda de cores
        # --------------------------
        with st.expander("üé® Legenda das Cores", expanded=True):
            st.markdown("""
            - üî¥ **Vermelho:** dezenas mais **atrasadas** (n√£o saem h√° muitos concursos).  
            - ‚ö™ **Branco:** dezenas **neutras**, dentro da m√©dia de sorteios.  
            - üîµ **Azul:** dezenas mais **frequentes** nos concursos recentes.
            """)

        for idx, (jogo, origem) in enumerate(jogos, start=1):
            # mostra origem por dezena se quiser (agora apenas emoji)
            display = []
            for d in jogo:
                tag = {"frequente": "üîµ", "atrasada": "üî¥", "aleatoria": "‚ö™", "aleatoria": "‚ö™"}.get(origem.get(d, "aleatoria"), "‚ö™")
                display.append(f"{tag} {d:02d}")
            st.markdown(f"üéØ **Jogo {idx} ({len(jogo)} dezenas):** {' '.join(display)}")

        # dados do bol√£o e gera√ß√£o de PDF/salvamento final
        st.markdown("---")
        st.subheader("üí¨ Dados do Bol√£o")
        participantes_input = st.text_input("üë• Participantes (separe por v√≠rgulas)", value=st.session_state.get("participantes", "Participante 01, Participante 02, Participante 03"))
        st.session_state["participantes"] = participantes_input
        pix_input = st.text_input("üí∏ Chave PIX para rateio", value=st.session_state.get("pix", "marcosmigueloliveira@yahoo.com.br"))
        st.session_state["pix"] = pix_input

        participantes_lista = [p.strip() for p in participantes_input.split(",") if p.strip()]
        valor_total = sum(calcular_valor_aposta(len(jogo)) for jogo, _ in jogos)
        valor_por_pessoa = (valor_total / len(participantes_lista)) if participantes_lista else valor_total

        st.subheader("üìä Rateio do Bol√£o")
        if participantes_lista:
            df_rateio = pd.DataFrame({"Participantes": participantes_lista, "Valor (R$)": [round(valor_por_pessoa, 2)] * len(participantes_lista)})
            st.dataframe(df_rateio, use_container_width=True)
        st.markdown(f"**üí∞ Valor total:** R$ {valor_total:,.2f}".replace(",", "X").replace(".", ",").replace("X", "."))

        if st.button("üìÑ Gerar PDF do Bol√£o"):
            arquivo_pdf = gerar_pdf_jogos(jogos, nome="Bol√£o Inteligente", participantes=participantes_input, pix=pix_input)
            codigo_bolao = salvar_bolao_csv(jogos, participantes_input, pix_input, valor_total, valor_por_pessoa, concurso_base=numero_api)
            if codigo_bolao:
                st.success(f"üìÑ PDF gerado e bol√£o salvo! C√≥digo: {codigo_bolao}")
            with open(arquivo_pdf, "rb") as f:
                st.download_button("‚¨áÔ∏è Baixar PDF", f, file_name=arquivo_pdf)
